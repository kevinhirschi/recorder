// recorder.js
// inspired by https://www.sitepoint.com/mediastream-api-record-audio/

// Use MediaStream API objects to capture media tracks
// link the button icon to the javascript

// hold the necessary elements
const recordButton = document.getElementById("recordButton"); //record button
const recordButtonImage = recordButton.firstElementChild;
const recordedAudioContainer = document.getElementById(  "recordedAudioContainer"); // recorded audio
const discardAudioButton = document.getElementById("discardButton"); // hold the discard button element
const saveAudioButton = document.getElementById("saveButton"); // hold the save button element
const recordingsContainer = document.getElementById("recordings"); //hold the #recordings element- fetched files
const scoreContainer = document.getElementById("scoreContainer"); // hold the score

//initialize elements to be used later
let chunks = []; // will be used later to record audio
let mediaRecorder = null; // will be used later to record audio; default value is null (thereâ€™s no ongoing recording)
let audioBlob = null; // the blob that will hold the recorded audio
var recordingJSON = {};
recordingJSON.File = '';
var recordingJSONGOPScores = [];


if(navigator.userAgent.match(/(iPhone|iPod|iPad|Safari)/i)){
navigator.mediaDevices.getUserMedia({     audio: true, // only record audio
        }).then((stream) => { 
		stream.getTracks().forEach(function(track) {track.stop();});
	});
};

// display json data generated by dsr gop alignment
function displayScore(jsonresults) {
  scoreContainer.innerHTML = "";
  //scoreContainer.innerHTML = renderResponse(jsonresults, scoreContainer);
  let results_audio_file = jsonresults.File.split('/')[5];
  results_audio_file = '/' + results_audio_file.split('wav')[0] + 'mp3';
  const recordingElement = createRecordingElement(results_audio_file, 99);
  scoreContainer.appendChild(recordingElement);

  //ChartGOP(jsonresults);
  scoreContainer.style.backgroundColor = "#5084d20a";
}

async function awaitData(url) {
  const response = await fetch(url);
  const data = await response.json();
  return data;
}

function colorprocessing(score) {
  var color = "#000000";
  if ((score) => 0) {
    color = "#de425b";
  }
  if (score > 0.5) {
    color = "#f0985e";
  }
  if (score > 0.6) {
    color = "#c1ae51";
  }
  if (score > 0.7) {
    color = "#899f3a";
  }
  if (score > 0.8) {
    color = "#488f31";
  }
  return color;
}

// render response
function renderResponse(jsonresults, targetcontainer) {
  //console.log(jsonresults.Results);
  var colorized_output = "";
  for (let i in jsonresults.Results) {
    var letter_obj = jsonresults.Results[i];
    var letter_out = Object.keys(letter_obj)[0];
    var letter_score = letter_obj[Object.keys(letter_obj)[0]];

    //cap first letter and change bar to space
    if ((i = 0)) {
      letter_out = letter_out.toUpperCase();
    }
    if (letter_out == "|") {
      letter_out = " ";
    }

    var color = colorprocessing(letter_score);
    colorized_output +=
      '<span style="color:' + color + ';" >' + letter_out + "</span>";
  }
  output_html =
    '<table><tr><td style="width:190px;height:70px;padding-left:5px;">' +
    colorized_output +
    '</td><td><canvas id="chart_'
    + jsonresults.GOPScore + 
    '"class="result_chart"> </canvas></td></tr></table>';
  return output_html;
}

function ChartGOP(GOPScore) {
  let yValues = [1 - GOPScore, GOPScore];
  let GOPscorecolor = colorprocessing(GOPScore);
  let barColors = ["#FFFFFF", GOPscorecolor];

  if(GOPScore < 0.001) {
    yValues = [0.5,0.5];
    barColors = ["#de425b","#de425b"];
  }

  new Chart("chart_" + GOPScore, {
    type: "doughnut",
    options: {
      tooltips: { enabled: false },
      hover: { mode: null },
    },
    data: {
      datasets: [
        {
          backgroundColor: barColors,
          data: yValues,
        },
      ],
    },
  });
}
// process asr gop
function ASRGopAlign(filename, targetstr) {
  var xhr = new XMLHttpRequest();
  posturl = "/asrgopalign.py?filename=" + filename + "&targetstr=" + targetstr;
  xhr.open("POST", posturl, true);
  xhr.onload = function () {
    //console.log(xhr.responseText);
    displayScore(xhr.responseText);
  };
  xhr.send();
}

// record click event - create a record function and it will be the event listener to the click event on recordButton
function record() {
 // if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
 //   alert("Your browser does not support recording!");
 //   return;
 // }

  // browser supports getUserMedia then change image in button
  recordButtonImage.src = `/images/${
    mediaRecorder && mediaRecorder.state === "recording" ? "microphone_asr" : "stop"
  }.png`;

  if (!mediaRecorder) {
    // check if mediaRecorder (defined at the beginning) is null (no ongoing recording)
    // start recording
    navigator.mediaDevices
      .getUserMedia({
        audio: {
  	     autoGainControl: true,  //chrom likes true -- safari like false
   	     echoCancellation: true, // chrome likes false --  safari likes true
   	     noiseSuppression: false, //chrome likes false
	     //latency: 0.003,
	     //sampleRate: 48000,
	     
	
    	}
      })
      .then((stream) => {
        // fulfillment handler: get a MediaStream instance to start recording
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.start();
        mediaRecorder.ondataavailable = mediaRecorderDataAvailable; // bound to a event handler
        mediaRecorder.onstop = mediaRecorderStop; // bound to a event handler
      })
      .catch((err) => {
        alert(`The following error occurred: ${err}`);
        // change image in button
        recordButtonImage.src = "/images/microphone_asr.png";
      });
  } else {
    // stop recording
    mediaRecorder.stop();
  }
}

// mediaRecorderDataAvailable function handles the dataAvailable event
// by adding the Blob audio track in the received BlobEvent parameter to the chunks array
function mediaRecorderDataAvailable(e) {
  chunks.push(e.data);
}

// mediaRecorderStop function removes any audio element that was previously recorded and not saved,
// creates a new audio media element, sets the src to be the Blob of the recorded stream, and shows the container
function mediaRecorderStop() {
  //check if there are any previous recordings and remove them
  if (recordedAudioContainer.firstElementChild.tagName === "AUDIO") {
    recordedAudioContainer.firstElementChild.remove();
  }
  //create a new audio element that will hold the recorded audio
  const audioElm = document.createElement("audio");
  audioElm.setAttribute("controls", ""); //add controls
  //create the Blob from the chunks
  audioBlob = new Blob(chunks, { type: "audio/mp3" });
  const audioURL = window.URL.createObjectURL(audioBlob);
  audioElm.src = audioURL;
  mediaRecorder = null;
  chunks = [];
  saveRecording();
  audioURL.src = null;
}

//  discard click event handler - functions discardRecording and resetRecording
function discardRecording() {
  //show the user the prompt to confirm they want to discard
  if (confirm("Are you sure you want to discard the recording?")) {
    //discard audio just recorded
    resetRecording();
  }
}

function resetRecording() {
  if (recordedAudioContainer.firstElementChild.tagName === "AUDIO") {
    //remove the audio
    recordedAudioContainer.firstElementChild.remove();
    //hide recordedAudioContainer
    recordedAudioContainer.classList.add("d-none");
    recordedAudioContainer.classList.remove("d-flex");
  }
  //reset audioBlob for the next recording
  audioBlob = null;
}

// save click event handler - upload the recording(s) to the server using Fetch API when user clicks Save button
function saveRecording() {
  //the form data that will hold the Blob to upload
  const formData = new FormData();
  //add the Blob to formData
  const filename = studentid + "_" + taskid + "_" + String(Date.now()) + ".mp3";
  formData.append("audio", audioBlob, filename);
  //send the request to the endpoint
  fetch("/record", {
    method: "POST",
    body: formData,
  })
    .then((response) => response.json())
    .then(() => {

      let posturl =
        "/asrgopalign.py?filename=" + filename + "&targetstr=" + targetstr;

      awaitData(posturl).then(function (data) {
        recordingJSONGOPScores = [];
        displayScore(data);
        resetRecording();
        fetchRecordings();
        updatecharts();
      });
    })


    .catch((err) => {
      console.error(err);
      alert("An error occurred, please try again later");
      //reset for next recording
      resetRecording();
      fetchRecordings();
      updatecharts();
    });
}

// fetchRecordings calls the endpoint created in index.js
function fetchRecordings() {
  fetch("/recordings")
    .then((response) => response.json())
    .then((response) => {
      if (response.success && response.files) {
        //remove all previous recordings shown
        recordingsContainer.innerHTML = "";
        var attempt = 1;
        response.files.forEach((file) => {
          //create the recording element
          //need to add if statement here kh
          if (
            file.split("_")[0] == "/" + studentid &&
            file.split("_")[1] == taskid
          ) {
            if (!recordingJSON.File.includes(file.slice(0,-3))) {
            const recordingElement = createRecordingElement(file, attempt);
            recordingsContainer.appendChild(recordingElement);
            attempt += 1;
            }
          }
        });
      }
    })
    .catch((err) => console.error(err));
}

//create the recording element - render the elements that will be the audio players.
function createRecordingElement(file, attempt) {
  //container element
  const recordingElement = document.createElement("div");
  recordingElement.classList.add("recording", "border");
  //audio element
  const audio = document.createElement("audio");
  audio.src = file;
  audio.onended = (e) => {
    //when the audio ends, change the image inside the button to play again
    e.target.nextElementSibling.firstElementChild.src = "images/play.png";
  };
  recordingElement.appendChild(audio);
  //button element
  const playButton = document.createElement("button");
  playButton.classList.add(
    "play-button",
    "btn",
    "border",
    "shadow-sm",
    "text-center",
    "mx-auto"
  );
  //image element inside button
  const playImage = document.createElement("img");
  playImage.src = "/images/play.png";
  playImage.classList.add("img-fluid");
  playButton.appendChild(playImage);
  //add event listener to the button to play the recording
  playButton.addEventListener("click", playRecording);
  recordingElement.appendChild(playButton);
  const AttemptLabel = document.createElement("label");
  AttemptLabel.classList.add("play_label");
  //const AttemptText = document.createTextNode("<span> Attempt </span>" + attempt);
  const AttemptDiv = document.createElement("div");
  AttemptDiv.innerHTML = '<table><tr><td style="width:190px;height:70px;padding-left:5px;">(Could not detect)</td></tr></table>';
  AttemptDiv.classList.add(file);

  //get json for recordings
  json_file_loc = "json" + file.substring(0, file.length - 3) + "json";
  $.getJSON(json_file_loc, callbackFuncWithData);

  function callbackFuncWithData(json) {
    recordingJSON = json;
    //console.log(recordingJSON);
    AttemptDiv.innerHTML = renderResponse(recordingJSON, AttemptDiv);
    recordingJSONGOPScores.push(recordingJSON.GOPScore);
  }

  AttemptLabel.appendChild(AttemptDiv);
  recordingElement.appendChild(AttemptLabel);
  //return the container element
  return recordingElement;
}

function playRecording(e) {
  let button = e.target;
  if (button.tagName === "IMG") {
    //get parent button
    button = button.parentElement;
  }
  //get audio sibling
  const audio = button.previousElementSibling;
  if (audio && audio.tagName === "AUDIO") {
    if (audio.paused) {
      //if audio is paused, play it
      audio.play();
      //change the image inside the button to pause
      button.firstElementChild.src = "images/pause.png";
    } else {
      //if audio is playing, pause it
      audio.pause();
      //change the image inside the button to play
      button.firstElementChild.src = "images/play.png";
    }
  }
}

function UrlExists(url) {
  var http = new XMLHttpRequest();
  http.open("HEAD", url, false);
  // http.send();
  //return http.status!=404;

  try {
    //var http = new XMLHttpRequest();
    //http.open('HEAD', url, false);
    http.send();
    return http.status != 404;
  } catch (error) {
    console.log(error);
    return false;
  }
}

function updatecharts() {
  setTimeout(function () {
      recordingJSONGOPScores.forEach((element) => {ChartGOP(element)})
  }, 800);
}

fetchRecordings();
updatecharts();

//add the event listeners to the button
recordButton.addEventListener("click", record); //record
discardAudioButton.addEventListener("click", discardRecording); //discard audio button
saveAudioButton.addEventListener("click", saveRecording); //save audio button
